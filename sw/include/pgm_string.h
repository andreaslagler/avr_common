/*typedef
Copyright (C) 2022  Andreas Lagler

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#ifndef PGM_STRING_H
#define PGM_STRING_H

#include <avr/pgmspace.h>

class PgmString
{
    public:
    
    class Iterator
    {
        public:
        
        constexpr Iterator(const char * const ptr)
        :
        m_ptr(ptr)
        {}
        
        ~Iterator() = default;
        
        constexpr Iterator& operator++()
        {
            ++m_ptr;
            return  *this;
        }
        
        char operator*() const
        {
            return pgm_read_byte(m_ptr);
        }
        
        constexpr bool operator!=(const Iterator other)
        {
            return m_ptr != other.m_ptr;
        }
        
        private:
        
        const char* m_ptr = nullptr;
    };

    ~PgmString() = default;
    
    constexpr Iterator begin() const
    {
        return Iterator(m_string);
    }

    constexpr Iterator end() const
    {
        return Iterator(m_string + m_size);
    }
    
    constexpr uint8_t size() const
    {
        return m_size;
    }

    private:
    
    // PgmString objects should only be generated by the _pgm operator
    // --> Declare _pgm operator as a friend
    // --> Declare constructor private
    template <typename Char, Char ... t_string>
    friend constexpr PgmString operator "" _pgm(); // warning: ISO C++ did not adopt string literal operator templates taking an argument pack of characters [-Wpedantic]
    
    constexpr PgmString(const char* str, const uint8_t size)
    :
    m_string(str),
    m_size(size)
    {}

    const char * const m_string = nullptr;
    const uint8_t m_size = 0;
    
    // Nested container to store a string literal in PROGMEM using an avr-gcc extension as described here: https://www.mikrocontroller.net/topic/410966
    template <typename Char, Char ... t_string>
    class PgmStringStorage
    {
        public:
        
        PgmStringStorage() = delete;

        static constexpr const char * str()
        {
            return s_data;
        }

        static constexpr uint8_t size()
        {
            return sizeof...(t_string);
        }

        private:

        // Compile-time constant string stored in PROGMEM
        static constexpr const char s_data[] PROGMEM = {t_string..., '\0'};
    };
};

// Static initialization
template <typename Char, Char ... t_string>
constexpr const char PgmString::PgmStringStorage<Char, t_string...>::s_data[] PROGMEM;

/**
@brief Postfix operator converting a string literal into a PgmString
@tparam Char This parameter is needed for the parameter pack to work
@tparam t_string The actual string literal passed as a parameter pack
*/
template <typename Char, Char ... t_string>
constexpr PgmString operator "" _pgm()
{
    return PgmString(
    PgmString::PgmStringStorage<Char, t_string ...>::str(),
    PgmString::PgmStringStorage<Char, t_string ...>::size());
}

#endif
